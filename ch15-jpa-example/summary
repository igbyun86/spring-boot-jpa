영속성 컨텍스트가 같다면 프록시로 조회된 엔티티와 원본 엔티티의 동일성, 동등성이 같다

-프록시의 동등성을 비교할 때 주의사항
프록시의 타입 비교는 == 비교 대신에 instanceof를 사용해야 한다.
프록시의 멤버변수에 직접 접근하면 안되고 대신에 접근자 메소드를 사용해야 한다.

프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성되는 문제가 있다.
-instanceof 연산을 사용할 수 없다.
-하위 타입으로 다운캐스팅을 할 수 없다.

※해결방법
1.JPQL로 대상 직접조회
-원본 엔티티는 가져올 수 있으나다형성을 활용할 수 없다.

2.프록시 벗기기
-하이버네이트가 제공하는 프록시에서 원본 엔티티를 찾는 기능을 사용해서 가져올 수 있으나
프록시와 프록시에서 꺼낸 원본 엔티티는 동일성 비교가 실패한다는 문제점이 있다.

3.기능을 위한 별도의 인터페이스 제공
4.Visitor 패턴 사용
-프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.
-instanceof와 타입캐스팅 없이 코드를 구현할 수 있다.
-알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.

단점
-너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어렵다.
-객체 구조가 변경되면 모든 Visitor를 수정해야 한다.

-N+1 정리
@OneToOne, @ManyToOne: 기본 페치 전략은 즉시 로딩
@OneToMany, @ManyToMany: 기본 페치 전략은 지연 로딩

기본값이 즉시 로딩인 @OneToOne, @ManyToOne은 fetch=FetchType=LAZY로 설정해서 지연 로딩 전략을 사용하고
성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.

-읽기 전용 쿼리의 성능 최적화
읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트를 동시에 사용하는 것이 가장 효과적이다.
읽기 전용 트랜잭션 사용: 플러시를 작동하지 않도록 해서 성능 향상
읽기 전용 쿼리 힌트: 엔티티를 읽기 전용으로 조회해서 메모리 절약



트랜잭션 ACID
-Atomicity(원자성)
:트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 모두 실패해야 한다.

-Consistency(일관성)
:모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.

-Isolation(격리성)
:동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.

-Durablity(지속성)
:트랜잭션이 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한
트랜잭션 내용을 복구해야 한다.

-트랜잭션 격리수준
-READ UNCOMMITTED
:커밋하지 않은 데이터를 읽을 수 있다.
수정중인 데이터를 다른 트랜잭션에서 조회하기 때문에 DIRTY READ가 발생한다.

-READ COMMITTED
:커밋한 데이터만 읽을 수 있다. DIRTY READ가 발생하지 않는다. 하지만 한 트랜잭션 안에서 같은 쿼리를 두번 실행 했을 때 다른 값이 나오는
NON-REPEATABLE READ가 발생한다.
예) 트랜잭션1이 회원 A를 조회 -> 트랜잭션2가 A를 수정 -> 트랜잭션1이 다시 A를 조회했을때 변경된 A가 조회됨
===트랜잭션 1===
begin
    select * from A

    ===트랜잭션 2===
    begin
        update A
    commit
    end
    ===트랜잭션 2 종료===

    select * from A -> 변경된 A가 조회됨
end

-REPEATABLE READ
:NON-REPEATABLE은 허용하지 않지만 하나의 트랜잭션 안에서 첫번째 쿼리 수행 결과와 두번째 쿼리 수행 결과 집합이 달라질 수 있다.
외부에 동시에 실행중인 트랜잭션의 Insert 작업에 의해 발생하는 PHANTOM READ가 발생한다.
===트랜잭션 1===
begin
    select * from A

    ===트랜잭션 2===
    begin
        insert A
    commit
    end
    ===트랜잭션 2 종료===

    select * from A -> 트랜잭션2에서 추가된 내용이 조회됨
end

-SERIALIZABLE
:가장 엄격한 트랜잭션 격리 수준이다. PHANTOM READ가 발생하진 않지만 동시성 처리 성능이 급격히 떨어질 수 있다.

-낙관적 락
:트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다. 데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라
JPA가 제공하는 버전 관리 기능을 사용한다. 애플리케이션이 제공하는 락이다.

-비관적 락
:트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸로 보는 방법이다. 데이터베이스가 제공하는 락 기능을 사용한다.

-두 번의 갱신 분실 문제
사용자 A와 B가 동시에 같은 게시글을 수정하는 중에 사용자 A가 먼저 수정완료를 하고 사용자 B가 수정완료를 진행한다.
결과적으로 먼저 완료한 사용자 A의 수정사항은 사라지고 사용자 B의 수정사항만 남게된다.

-두 번의 갱신 분실 문제 해결 방법
    -마지막 커밋만 인정하기(기본방법)
    -최초 커밋만 인정하기
    -충돌하는 갱신 내용 병합하기

-@Version
JPA가 제공하는 버전 관리 기능

버전 정보를 사용하면 최초 커밋만 인정하기가 적용된다.
===트랜잭션 1===
begin
    select * from A     // version:1

    ===트랜잭션 2===
    begin
        select * from A
        update A
    commit
    end                 // version:2
    ===트랜잭션 2 종료===

    update A -> 엔티티를 조회할 때 버전과 현재의 버전이 다르므로 예외가 발생한다.
end

-버전 사용 엔티티 SQL
UPDATE  BOARD
SET     TITLE = ?
        ,VERSION = ? //(버전 + 1증가)
WHERE   ID = ?
AND     VERSION = ? //(버전 비교)
//'버전은 엔티티의 값을 변경하면 증가한다!!!' 단 연관관계 필드는 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전이 증가한다.

※벌크 연산은 버전을 무시한다. 벌크 연산에서 버전을 증가하려면 버전 필드를 강제로 증가시켜야 한다.
update Member m
set m.name = '변경'
    ,m.version = m.version + 1


-JPA 락 사용
: 추천 전략은 READ COMMITED 트랜잭션 격리 수준 + 낙관적 버전 관리(두 번의 갱신 내역 분실 문제 예방)



------------------------------------------------------------------------------------------------------------------------
-LockModeType
------------------------------------------------------------------------------------------------------------------------

/==JPA 낙관적 락==/
JPA가 제공하는 낙관적 락은 버전(@Version)을 사용한다.
락 옵션 없이 @Version만 있어도 낙관적 락이 적용된다. 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다는 특징이 있다.

-NONE
:락 옵션을 적용하지 않아도 엔티티에 @Version이 적용된 필드만 있으면 낙관적 락이 적용된다.
-용도
:조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않아야 한다. 조회 시점부터 수정 시점까지를 보장한다.
-동작
:엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다.(UPDATE 쿼리 사용). 이때 데이터베이스의 버전 값이 현재 버전이 아니면 예외가 발생한다.
-이점
:두 번의 갱신 분실 문제를 예방한다.

-OPTIMISTIC
:@Version만 적용했을 때는 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다.
 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.
-용도
:조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변경되지 않아야 한다. 트랜잭션이 끝날때까지 조회한 엔티티가 변경되지 않음을 보장한다.
-동작
:트랜잭션을 커밋할 때 버전 정보를 조회해서(SELECT 쿼리 사용) 현재 엔티티의 버전과 같은지 검증한다. 만약 같지 않으면 예외가 발생한다.
-이점
:OPTIMISTIC 옵션은 DIRTY READ와 NON-REPEATABLE READ를 방지한다.

//트랜잭션1 조회 title="제목A", version=1
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);

//중간에 트랜잭션 2에서 해당 게시물을 수정해서 title="제목C", version=2로 증가
...

//트랜잭션1 커밋 시점에 버전정보 검증, 예외 발생
//(데이터베이스 version=2, 엔티티 version=1)
tx.commit();

===트랜잭션 1===
begin
    select * from A     // version:1

    ===트랜잭션 2===
    begin
        select * from A
        update A
    commit
    end                 // version:2
    ===트랜잭션 2 종료===

    select * from A -> 엔티티를 조회할 때 버전과 현재의 버전이 다르므로 예외가 발생한다.
end

-OPTIMISTIC_FORCE_INCREMENT
:낙관전 락을 사용하면서 버전 정보를 강제로 증가한다.(조회만 해도 버전을 증가시킨다.)
-용도
:논리적인 단위의 엔티티 묶음을 관리할 수 잇다.
-동작
:엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.
이때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다.
추가로 엔티티를 수정하면 수정 시 버전 UPDATE가 발생한다. 따라서 총 2번의 버전 증가가 나타날 수 있다.
-이점
:강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다.

//트랜잭션1 조회 title="제목A", version=1
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT);

//트랜잭션1 커밋 시점에 버전 강제 증가
tx.commit();    //version=2


/==JPA 비관적 락==/
데이터베이스 트랜잭션 락 매커니즘에 의존하는 방법이다. 주로 SQL 쿼리에 select for update 구문을 사용하면서 시작하고
버전 정보는 사용하지 않는다. 비관적 락은 주로 PRESSIMISTIC_WRITE 모드를 사용한다.

-특징
  -엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.
  -데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다.

-PESSIMISTIC_WRITE
:비관적 락이라 하면 일반적으로 이 옵션을 뜻한다. 데이터베이스에 쓰기 락을 걸 때 사용한다.
-용도
:데이터베이스에 쓰기 락을 건다.
-동작
:데이터베이스 select for update를 사용해서 락을 건다.
-이점
:NON-REPEATABLE READ를 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다.

-PESSIMISTIC_READ
:데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다. 일반적으로 잘 사용하지 않는다.
데이터베이스 대부분은 방언에 의해 PESSIMISTIC_WRITE로 동작한다.

-PESSIMISTIC_FORCE_INCREMENT
:비관적 락중 유일하게 버전 정보를 사용한다. 비관적 락이지만 버전 정보를 강제로 증가시킨다.

-비관적 락과 타임아웃
:락을 획득할 때까지 트랜잭션이 대기한다. 하지만 무한정 기다릴 수 없으므로 타임아웃 시간을 줄 수 있다.

Map<String, Object> properties = new HashMap<>();

//타임아웃 10초까지 대기 설정(데이터베이스 특성에 따라 동작하지 않을 수 있다.)
properties.puut("javax.persistence.lock.timeout", 10000);

Board board = em.find(Board.class, id, LockModeType.PESSIMISTIC_WRITE, properties);




